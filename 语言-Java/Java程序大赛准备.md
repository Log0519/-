# Java程序大赛准备
@[toc]
## 零、知识点
1、关键字区分大小写

2、java可以自定义类的销毁方法，但不能手动决定对象何时销毁

3、continue语句后可以加入标签实现跳转到指定位置；

4、严格来说Java是一种解释性语言。

5、如果没有public类，Java文件可以随意命名

6、jsp需要安装tomcat

7、处理异常可以只包含try、 finally，没有catch

8、实现每隔一小时查询某变量的值，并且不影响程序运行，使用timer.schedule（），每小时启动一个线程，在新线程中查询该变量，之后立刻关闭。

9、final 类不可以有子类

10、Java类只能是单继承的

11、匿名类可以是内部类

12、public类和没有修饰符的类有一定区别

13、内部类可以直接访问外部类的成员

14、没有main方法的java文件即使可以独立编译，也无法独立运行。

15、Set<Integer> windowSet=new HashSet<>();

        List<List<Integer>> res = new ArrayList<>();

        list.add(nums1[i]);

        int[] arr = new int[length];

16、//数字转化为字符数组

char[] numChar = String.valueOf(n).toCharArray();

17、 Java中有三大变量？

- **实例**变量：在**堆**中
- **静态**变量：在**方法区**
- **局部**变量：在**栈**中

### 空间占用

1个字节8位
计算机的基本单位：bit .　　

一个bit代表一个0或1

1个字节是8个bit

--**byte**：1byte = 8bit　　

--**boolean**：1byte　　 

--**short**：2byte

--**char**：2byte

--**int**：4byte

--**float**：4byte

--**double**：8byte

--**long**：8byte

## 一、重载、重写类题目

### 1、重写

重写后的方法与被重写的方法**不能**具有不同的参数表

重写后的方法**不能**比被重写的方法具有更严格的访问权限

重写后的方法与被重写的方法**不能**具有不同类型的返回值

重写后的方法**可以**比被重写的方法产生更少的例外

### 2、重载

重载后的方法与被重载的方法**一定具有不同**的参数表

重载后的方法**不一定**比被重载的方法具有更严格的访问权限

重载后的方法与被重载的方法**不一定**具有**不同类型**的返回值

重载后的方法**不一定比**被重载的方法产生更多的例外

## 二、构造方法

1、构造方法是类的一种特殊方法，其方法名**必须**与类名相同

2、构造方法的主要作用是对类的对象进行初始化工作

3、Java中类的构造方法名称**必须**与类的名称相同

4、在创建对象时，系统会自动调用构造方法

5、构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。

6、构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。

7、一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。

8、构造方法可以重载，以参数的个数，类型，顺序。

## 三、抽象类

1、抽象类**不能**用new运算符创建对象

2、抽象类的非抽象子类**必须**重写父类中的abstract方法

3、抽象类中**可以**有非abstract方法

4、抽象类中可以构造方法

5、抽象类中可以存在普通属性，方法，静态属性和方法。

6、抽象类中可以存在抽象方法。

7、如果一个类中有一个抽象方法，那么当前类**一定**是抽象类；抽象类中**不一定**有抽象方法。

8、抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。

## 四、内存回收

1、内存回收程序负责释放无用内存

2、内存回收程序**不允许**程序员直接释放内存

3、内存回收程序**不可以**由程序员释放指定的内存对象

4、程序员**不需要**创建一个线程来释放内存；

## 五、文件操作

1、Java中打开磁盘文件c:xt,不会用到的类是（Socket）。

InputStream、File、FileReader会用到

2、Java中处理中文输入，不需要用到的类是（OutputStream）。

BufferedReader、InputStream、System.in会用到

3、分为字节流和字符流，字符流主要对于中文，底层转化为字节。

4、字符流(reader)、字节流(OutputStream,InputStream)

## 六、接口

1、非抽象类A在继承接口B时，**必须**重写(Override)B中所有抽象方法

2、在接口中**只有**方法的声明，没有方法体。

3、在接口中**只有**常量，因为定义的变量，在编译的时候都会默认加上

<mark>public static final</mark>

4、在接口中的方法，**永远**都被public来修饰。

5、接口中**没有**构造方法，也**不能**实例化接口的对象。

6、接口**可以**实现多继承

7、接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法，则实现类定义为抽象类。

## 七、内部类

#### 0、内部类

在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。

#### 1、成员内部类

1.1、该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；

1.2、成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员

内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；

1.3、在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；

1.4、成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；

1.5、内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。

#### 2、局部内部类

2.1、局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；

2.2、局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

#### 3、匿名内部类

3.1、一般使用匿名内部类的方法来编写事件监听代码；

3.2、匿名内部类是不能有访问修饰符和static修饰符的；

3.3、匿名内部类是唯一一种没有构造器的类；

3.4、匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

#### 4、内部静态类

4.1、静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；

4.2、不能使用外部类的非static成员变量或者方法。

## 八、JVM内存五大区域

虚拟机栈(栈帧)

本地方法栈

PC寄存器

方法区

堆

## 九、Yield

1、Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。

2、yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

3、结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

## 十、Default和Protected区别

1、前者只要是外部包，就不允许访问。

2、后者只要是子类就允许访问，即使子类位于外部包。

3、总结：default拒绝一切包外访问；protected接受包外的子类访问

## 十一、Error 和 Exception 区别

1、  Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类有两个重要的子类 Exception （异常）和 Error （错误）。
2、 Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。
 3、Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对
其进行处理，使应用程序可以继续正常运行。 Exception 又可以分为运行时异常(RuntimeException, 又叫非受检查异常)和非运行时异常(又叫受检查异常) 。
 4、Error ： Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。

## 十二、自动类型转换规则

1.若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。

2.转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。

3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。

4.char型和short型参与运算时，必须先转换成int型。

5.在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。

## 十三、类方法与实例方法

在类方法中调用本类的类方法可直接调用。 实例方法也叫做对象方法。
类方法是属于整个类的，而实例方法是属于类的某个对象的。
由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制： 
(1) 类方法中不能引用对象变量；
(2) 类方法中不能调用类的对象方法；
(3) 在类方法中不能使用super、this关键字。
(4)类方法不能被覆盖。 
如果违反这些限制，就会导致程序编译错误。
与类方法相比，对象方法几乎没有什么限制：
(1) 对象方法中可以引用对象变量，也可以引用类变量；
(2) 对象方法中可以调用类方法；
(3) 对象方法中可以使用super、this关键字。

## 十四、单例模式

### 1、单例模式的定义

定义： 确保一个类只有一个实例，并提供该实例的全局访问点。

这样做的好处是：有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。

### 2、单例模式的设计要素

一个私有构造函数 （确保只能单例类自己创建实例）
一个私有静态变量 （确保只有一个实例）
一个公有静态函数 （给使用者提供调用方法）
简单来说就是，单例类的构造方法不让其他人修改和使用；并且单例类自己只创建一个实例，这个实例，其他人也无法修改和直接使用；然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一次实例。

### 3、单例模式的6种实现及各实现的优缺点

#### （1）懒汉式（线程不安全）

说明： 先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。

优点： 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。

缺点： 线程不安全，多线程环境下，如果多个线程同时进入了 if (uniqueInstance == null) ，若此时还未实例化，也就是uniqueInstance == null，那么就会有多个线程执行 uniqueInstance = new Singleton(); ，就会实例化多个实例；

#### （2）饿汉式（线程安全）

说明： 先不管需不需要使用这个实例，直接先实例化好实例 (饿死鬼一样，所以称为饿汉式)，然后当需要使用的时候，直接调方法就可以使用了。

优点： 提前实例化好了一个实例，避免了线程不安全问题的出现。

缺点： 直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会操作系统的资源浪费。

#### （3）懒汉式（线程安全）

说明： 实现和 线程不安全的懒汉式 几乎一样，唯一不同的点是，在get方法上 加了一把 锁。如此一来，多个线程访问，每次只有拿到锁的的线程能够进入该方法，避免了多线程不安全问题的出现。

优点： 延迟实例化，节约了资源，并且是线程安全的。

缺点： 虽然解决了线程安全问题，但是性能降低了。因为，即使实例已经实例化了，既后续不会再出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方***使线程阻塞，等待时间过长。

#### （4）双重检查锁实现（线程安全）

说明: 双重检查数相当于是改进了 线程安全的懒汉式。线程安全的懒汉式 的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。

为什么使用 volatile 关键字修饰了 uniqueInstance 实例变量 ？

uniqueInstance = new Singleton(); 这段代码执行时分为三步：

1、为 uniqueInstance 分配内存空间
2、初始化 uniqueInstance
3、将 uniqueInstance 指向分配的内存地址
正常的执行顺序当然是 1>2>3 ，但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。
单线程环境时，指令重排并没有什么问题；多线程环境时，会导致有些线程可能会获取到还没初始化的实例。
例如：线程A 只执行了 1 和 3 ，此时线程B来调用 getUniqueInstance()，发现 uniqueInstance 不为空，便获取 uniqueInstance 实例，但是其实此时的 uniqueInstance 还没有初始化。

解决办法就是加一个 volatile 关键字修饰 uniqueInstance ，volatile 会禁止 JVM 的指令重排，就可以保证多线程环境下的安全运行。

优点： 延迟实例化，节约了资源；线程安全；并且相对于 线程安全的懒汉式，性能提高了。

缺点： volatile 关键字，对性能也有一些影响。

#### （5）静态内部类实现（线程安全）

说明： 首先，当外部类 Singleton 被加载时，静态内部类 SingletonHolder 并没有被加载进内存。当调用 getUniqueInstance() 方法时，会运行 return SingletonHolder.INSTANCE; ，触发了 SingletonHolder.INSTANCE ，此时静态内部类 SingletonHolder 才会被加载进内存，并且初始化 INSTANCE 实例，而且 JVM 会确保 INSTANCE 只被实例化一次。

优点： 延迟实例化，节约了资源；且线程安全；性能也提高了。

#### （6）枚举类实现（线程安全）

说明： 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。

优点： 写法简单，线程安全，天然防止反射和反序列化调用。

防止反序列化
序列化：把java对象转换为字节序列的过程；
反序列化： 通过这些字节序列在内存中新建java对象的过程；
说明： 反序列化 将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。
我们要防止反序列化，避免得到多个实例。
枚举类天然防止反序列化。
其他单例模式 可以通过 重写 readResolve() 方法，从而防止反序列化，使实例唯一重写 readResolve() :

### 4、单例模式应用场景举例

- 网站计数器。
- 应用程序的日志应用。
- Web项目中的配置对象的读取。
- 数据库连接池。
- 多线程池。
- ......

## 十五、不会初始化子类的几种

不会初始化子类的几种

1. 调用的是父类的static方法或者字段

2.调用的是父类的final方法或者字段

3. 通过数组来引用

## 十六 、Request范围内的几个方法

request.getAttribute()方法返回request范围内存在的对象

request.getParameter()方法是获取http提交过来的数据。

getAttribute是返回对象。

getParameter返回字符串。

## 十七、值传递和引用传递

1、值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.

2、引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 所以对引用对象进行操作会同时改变原对象.

3、一般认为,**java内的传递都是值传递.**

## 十八、String StringBuffer StringBuilder

1.操作数量较少的字符串用String，不可修改的字符串；
2.在单线程且操作大量字符串用StringBuilder,速度快，但线程不安全，可修改；
3.在多线程且操作大量字符串用StringBuffer，线程安全，可修改。
4、String 定义的是字符串常量，其値一旦定义就不再改变，如下：

```java
String s = “ABC”;
S = s.subString(2); //会重新生成一个字符串对象
```

以上两句执行后在内存中会产生“两”个字符串对象 一个”ABC”,另一个是s指向的”AB”(注意s已不再指向”ABC”)```

5、StringBuffer 定义的是字符串变量，其値可以改变，如下：

6、StringBuffer s1 = new StringBuffer(“ABC”);

## 十九、==

如果两边是引用类型，存的值是对象的地址，如果两个对象的引用完全相同（指向同一个对象）时，将返回true，否则返回false。
“==”如果两边是基本类型，就是比较数值是否相等。

基本数据类型比较的是值，引用数据类型比较的是内存地址

因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

## 二十、volatile

1、volatile关键字是用来保证有序性和可见性的

2、对一个变量的写操作先行发生于后面对这个变量的读操作

3、首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中

## 二十一、反射

反射
JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息；

获取一个class对应的Class实例后，就可以获取该class的所有信息；

通过Class实例获取class信息的方法称为反射（Reflection）；

JVM总是动态加载class，可以在运行期根据条件来控制加载class。

## 二十二、equals HashCode()

1、如果a和b相等，那么a.equals(b)一定为true，则a.hashCode()必须等于b.hashCode()；
2、如果a和b不相等，那么a.equals(b)一定为false，则a.hashCode()和b.hashCode()尽量不要相等。

## 二十三、线程

1.线程同步的概念： 当多个线程同时使用一个对象时，由于线程本身运行的不确定性，可能会造成操作的不完整性，故而引入同步

2.Java中同步的方式有两种， Synchronized 和 Lock

3.当一个线程进入一个对象的同步方法后，它会把该对象锁住，其它的线程不能再使用该对象(包括对象的任何方法，属性)，直到该线程释放掉锁，其它线程才有机会使用该对象

4.一个线程释放同步锁的条件：

a. 正常运行完(退出synchronized块)

b. 使用wait()方法
